#!/bin/bash

######################################################################
#           Auto Install & Optimize LEMP Stack on Ubuntu             #
#                                                                    #
#                Author: Sanvv - HOSTVN Technical                    #
#                  Website: https://hostvn.vn                        #
#                                                                    #
#              Please do not remove copyright. Thank!                #
#  Please do not copy under any circumstance for commercial reason!  #
######################################################################

CF_CONFIG_FILE="/var/hostvn/.cloudflare.conf"

_save_cloudflare_config() {
    # Store Cloudflare API key and email for reuse
    local cf_email=$1
    local cf_api_key=$2
    local auth_method=${3:-"key"}

    if [[ -f "${CF_CONFIG_FILE}" ]]; then
        rm -f "${CF_CONFIG_FILE}"
    fi

    cat > "${CF_CONFIG_FILE}" << EOF
CF_EMAIL="${cf_email}"
CF_API_KEY="${cf_api_key}"
CF_AUTH_METHOD="${auth_method}"
CF_CONNECTED_AT="$(date "+%Y-%m-%d %H:%M:%S")"
EOF

    chmod 600 "${CF_CONFIG_FILE}"
}

_load_cloudflare_config() {
    if [[ -f "${CF_CONFIG_FILE}" ]]; then
        source "${CF_CONFIG_FILE}"
    fi

    # Check if variables are set
    if [[ -z "${CF_EMAIL}" || -z "${CF_API_KEY}" ]]; then
        return 1
    fi
    
    return 0
}

_validate_api_key() {
    local cf_email=$1
    local cf_api_key=$2
    local is_token=0
    # Nếu key chứa dấu chấm hoặc dài hơn 40 ký tự thì coi là API Token
    if [[ "${cf_api_key}" == *.* || ${#cf_api_key} -gt 40 ]]; then
        is_token=1
    fi
    local response
    if [[ $is_token -eq 1 ]]; then
        # Xác thực API Token
        response=$(curl -s -X GET "https://api.cloudflare.com/client/v4/user/tokens/verify" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json")
        echo "${response}" > "/tmp/cloudflare_api_debug.log"
        if [[ "$(echo "${response}" | grep -o '"success":true')" ]]; then
            export CF_AUTH_METHOD="token"
            return 0
        else
            echo "\n[Cloudflare] Lỗi xác thực API Token!\n" >&2
            echo "- API Token không hợp lệ hoặc không đủ quyền." >&2
            echo "- Vào Cloudflare Dashboard > API Tokens > Create Token hoặc View, đảm bảo token có quyền quản lý zone." >&2
            echo "- Nếu đã đúng mà vẫn lỗi, kiểm tra lại quyền hoặc thử tạo token mới." >&2
            local error_message
            error_message=$(echo "${response}" | grep -o '"message":"[^\"]*' | cut -d'"' -f4)
            echo "Authentication Error: ${error_message}" >> "/tmp/cloudflare_api_debug.log"
            return 1
        fi
    else
        # Xác thực Global API Key
        response=$(curl -s -X GET "https://api.cloudflare.com/client/v4/user" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json")
        echo "${response}" > "/tmp/cloudflare_api_debug.log"
        if [[ "$(echo "${response}" | grep -o '"success":true')" ]]; then
            export CF_AUTH_METHOD="key"
            return 0
        else
            echo "\n[Cloudflare] Lỗi xác thực Global API Key!\n" >&2
            echo "- API Key không hợp lệ hoặc không đủ quyền." >&2
            echo "- Vào Cloudflare Dashboard > My Profile > API Tokens > Global API Key > View để lấy key dài (~37 ký tự)." >&2
            echo "- Nếu đã đúng mà vẫn lỗi, kiểm tra lại quyền hoặc thử tạo key mới." >&2
            local error_message
            error_message=$(echo "${response}" | grep -o '"message":"[^\"]*' | cut -d'"' -f4)
            echo "Authentication Error: ${error_message}" >> "/tmp/cloudflare_api_debug.log"
            return 1
        fi
    fi
}

_get_cloudflare_zones() {
    local cf_email=$1
    local cf_api_key=$2
    local auth_method=${CF_AUTH_METHOD:-"key"}
    
    _debug_log "Getting Cloudflare zones for email: ${cf_email}, auth_method: ${auth_method}"
    
    # Get list of zones (domains)
    local response
    
    if [[ "${auth_method}" == "token" ]]; then
        _debug_log "Using Bearer token authentication for zones"
        response=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?per_page=50" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json")
    else
        _debug_log "Using email/key authentication for zones"
        response=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?per_page=50" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json")
    fi

    _debug_response "${response}" "GET_ZONES"
    echo "${response}"
}

_get_zone_id() {
    local cf_email=$1
    local cf_api_key=$2
    local domain=$3
    local auth_method=${CF_AUTH_METHOD:-"key"}
    
    _debug_log "Getting zone ID for domain: ${domain}"
    
    # Get zone ID for a domain
    local response
    
    if [[ "${auth_method}" == "token" ]]; then
        _debug_log "Using Bearer token for zone ID lookup"
        response=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=${domain}" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json")
    else
        _debug_log "Using email/key for zone ID lookup"
        response=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=${domain}" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json")
    fi

    _debug_response "${response}" "GET_ZONE_ID"

    # Extract zone ID
    local zone_id
    if command -v jq >/dev/null 2>&1; then
        zone_id=$(echo "${response}" | jq -r '.result[0].id' 2>/dev/null)
        if [[ "${zone_id}" == "null" ]]; then
            zone_id=""
        fi
    else
        zone_id=$(echo "${response}" | grep -o '"id":"[^"]*' | head -n1 | cut -d'"' -f4)
    fi
    
    _debug_log "Extracted zone ID: ${zone_id}"
    echo "${zone_id}"
}

_add_domain_to_cloudflare() {
    local cf_email=$1
    local cf_api_key=$2
    local domain=$3
    local auth_method=${CF_AUTH_METHOD:-key}
    
    # Add domain to Cloudflare
    local response
    if [[ "${auth_method}" == "token" ]]; then
        response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data "{\"name\":\"${domain}\",\"jump_start\":true}")
    else
        response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data "{\"name\":\"${domain}\",\"jump_start\":true}")
    fi

    # Check if the domain was added successfully
    if [[ "$(echo "${response}" | grep -o '"success":true')" ]]; then
        # Extract nameservers (improved, avoid lỗi chỉ lấy 1 NS)
        local ns1 ns2
        ns1=$(echo "${response}" | grep -o '"name_servers":\[[^]]*' | head -n1 | sed 's/.*\["\([^"]*\)".*/\1/')
        ns2=$(echo "${response}" | grep -o '"name_servers":\[[^]]*' | head -n1 | sed 's/.*\["[^"]*",[ ]*"\([^"]*\)".*/\1/')
        # Nếu không lấy được NS2 thì fallback về cách cũ
        if [[ -z "$ns2" || "$ns2" == "$ns1" ]]; then
            ns2=$(echo "${response}" | grep -o '"name_servers":\[[^]]*' | grep -o '"[^"]*"' | sed 's/"//g' | head -n2 | tail -n1)
        fi
        echo "success:${ns1}:${ns2}"
    else
        local error=$(echo "${response}" | grep -o '"message":"[^\"]*' | cut -d'"' -f4)
        echo "error:${error}"
    fi
}

_add_dns_record() {
    local cf_email=$1
    local cf_api_key=$2
    local zone_id=$3
    local record_type=$4  # A, CNAME, etc.
    local record_name=$5  # subdomain or @
    local record_content=$6  # IP address or target domain
    local proxied=$7  # true or false
    local auth_method=${CF_AUTH_METHOD:-"key"}
    
    _debug_log "Adding DNS record: ${record_type} ${record_name} -> ${record_content} (proxied: ${proxied})"
    _debug_log "Zone ID: ${zone_id}, Auth method: ${auth_method}"
    
    # Add DNS record
    local response
    local curl_data="{\"type\":\"${record_type}\",\"name\":\"${record_name}\",\"content\":\"${record_content}\",\"ttl\":1,\"proxied\":${proxied}}"
    
    _debug_log "Request data: ${curl_data}"
    
    if [[ "${auth_method}" == "token" ]]; then
        _debug_log "Using Bearer token authentication"
        response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/dns_records" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data "${curl_data}")
    else
        _debug_log "Using email/key authentication"
        response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/dns_records" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data "${curl_data}")
    fi

    _debug_response "${response}" "ADD_DNS_RECORD"

    # Check if the record was added successfully
    if [[ "$(echo "${response}" | grep -o '"success":true')" ]]; then
        _debug_log "DNS record added successfully"
        echo "success"
    else
        local error=$(echo "${response}" | grep -o '"message":"[^"]*' | cut -d'"' -f4)
        _debug_log "DNS record add failed: ${error}"
        echo "error:${error}"
    fi
}

_get_dns_records() {
    local cf_email=$1
    local cf_api_key=$2
    local zone_id=$3
    local record_type=${4:-""}  # Optional: filter by type (A, AAAA)
    local auth_method=${CF_AUTH_METHOD:-"key"}
    
    _debug_log "Getting DNS records for zone_id: ${zone_id}, auth_method: ${auth_method}"
    
    local url="https://api.cloudflare.com/client/v4/zones/${zone_id}/dns_records"
    if [[ -n "${record_type}" ]]; then
        url="${url}?type=${record_type}"
    fi
    
    _debug_log "API URL: ${url}"
    
    local response
    if [[ "${auth_method}" == "token" ]]; then
        _debug_log "Using API Token authentication"
        response=$(curl -s -X GET "${url}" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json")
    else
        _debug_log "Using Global API Key authentication with email: ${cf_email}"
        response=$(curl -s -X GET "${url}" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json")
    fi

    _debug_response "${response}" "GET_DNS_RECORDS"
    echo "${response}"
}

_update_dns_record() {
    local cf_email=$1
    local cf_api_key=$2
    local zone_id=$3
    local record_id=$4
    local record_type=$5
    local record_name=$6
    local record_content=$7
    local proxied=$8
    local auth_method=${CF_AUTH_METHOD:-"key"}
    
    local response
    if [[ "${auth_method}" == "token" ]]; then
        response=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/${zone_id}/dns_records/${record_id}" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data "{\"type\":\"${record_type}\",\"name\":\"${record_name}\",\"content\":\"${record_content}\",\"ttl\":1,\"proxied\":${proxied}}")
    else
        response=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/${zone_id}/dns_records/${record_id}" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data "{\"type\":\"${record_type}\",\"name\":\"${record_name}\",\"content\":\"${record_content}\",\"ttl\":1,\"proxied\":${proxied}}")
    fi

    if [[ "$(echo "${response}" | grep -o '"success":true')" ]]; then
        echo "success"
    else
        local error=$(echo "${response}" | grep -o '"message":"[^"]*' | cut -d'"' -f4)
        echo "error:${error}"
    fi
}

_delete_dns_record() {
    local cf_email=$1
    local cf_api_key=$2
    local zone_id=$3
    local record_id=$4
    local auth_method=${CF_AUTH_METHOD:-"key"}
    
    local response
    if [[ "${auth_method}" == "token" ]]; then
        response=$(curl -s -X DELETE "https://api.cloudflare.com/client/v4/zones/${zone_id}/dns_records/${record_id}" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json")
    else
        response=$(curl -s -X DELETE "https://api.cloudflare.com/client/v4/zones/${zone_id}/dns_records/${record_id}" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json")
    fi

    if [[ "$(echo "${response}" | grep -o '"success":true')" ]]; then
        echo "success"
    else
        local error=$(echo "${response}" | grep -o '"message":"[^"]*' | cut -d'"' -f4)
        echo "error:${error}"
    fi
}

_create_security_rule() {
    local cf_email=$1
    local cf_api_key=$2
    local zone_id=$3
    local rule_name=$4
    local expression=$5  # Filter expression
    local action=$6  # block, js_challenge, challenge
    local auth_method=${CF_AUTH_METHOD:-"key"}
    
    # Create security rule
    local response
    
    if [[ "${auth_method}" == "token" ]]; then
        response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/firewall/rules" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data "{\"filter\":{\"expression\":\"${expression}\"},\"action\":\"${action}\",\"description\":\"${rule_name}\"}")
    else
        response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/firewall/rules" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data "{\"filter\":{\"expression\":\"${expression}\"},\"action\":\"${action}\",\"description\":\"${rule_name}\"}")
    fi

    # Check if the rule was created successfully
    if [[ "$(echo "${response}" | grep -o '"success":true')" ]]; then
        echo "success"
    else
        local error=$(echo "${response}" | grep -o '"message":"[^"]*' | cut -d'"' -f4)
        echo "error:${error}"
    fi
}

_purge_cache() {
    local cf_email=$1
    local cf_api_key=$2
    local zone_id=$3
    local auth_method=${CF_AUTH_METHOD:-"key"}
    
    # Purge all cache
    local response
    
    if [[ "${auth_method}" == "token" ]]; then
        response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/purge_cache" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data '{"purge_everything":true}')
    else
        response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/purge_cache" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data '{"purge_everything":true}')
    fi

    # Check if the cache was purged successfully
    if [[ "$(echo "${response}" | grep -o '"success":true')" ]]; then
        echo "success"
    else
        local error=$(echo "${response}" | grep -o '"message":"[^"]*' | cut -d'"' -f4)
        echo "error:${error}"
    fi
}

_update_cache_settings() {
    local cf_email=$1
    local cf_api_key=$2
    local zone_id=$3
    local setting_name=$4  # cache_reserve, tiered_cache, etc.
    local value=$5  # on or off
    local auth_method=${CF_AUTH_METHOD:-"key"}
    
    # Update cache settings
    local response
    
    if [[ "${auth_method}" == "token" ]]; then
        response=$(curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/${zone_id}/settings/${setting_name}" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data "{\"value\":\"${value}\"}")
    else
        response=$(curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/${zone_id}/settings/${setting_name}" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data "{\"value\":\"${value}\"}")
    fi

    # Check if the setting was updated successfully
    if [[ "$(echo "${response}" | grep -o '"success":true')" ]]; then
        echo "success"
    else
        local error=$(echo "${response}" | grep -o '"message":"[^"]*' | cut -d'"' -f4)
        echo "error:${error}"
    fi
}

_create_bot_management_rule() {
    local cf_email=$1
    local cf_api_key=$2
    local zone_id=$3
    local auth_method=${CF_AUTH_METHOD:-"key"}
    
    # Create rule to block AI bots
    local response
    
    if [[ "${auth_method}" == "token" ]]; then
        response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/rulesets/phases/http_request_firewall_managed/entrypoint" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data '{
                "description": "Block AI bots",
                "rules": [
                    {
                        "action": "block",
                        "expression": "cf.client.bot or cf.threat_score > 10",
                        "description": "Block AI crawlers and high threat bots"
                    }
                ]
            }')
    else
        response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/rulesets/phases/http_request_firewall_managed/entrypoint" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data '{
                "description": "Block AI bots",
                "rules": [
                    {
                        "action": "block",
                        "expression": "cf.client.bot or cf.threat_score > 10",
                        "description": "Block AI crawlers and high threat bots"
                    }
                ]
            }')
    fi

    # Check if the rule was created successfully
    if [[ "$(echo "${response}" | grep -o '"success":true')" ]]; then
        echo "success"
    else
        local error=$(echo "${response}" | grep -o '"message":"[^"]*' | cut -d'"' -f4)
        echo "error:${error}"
    fi
}

_enable_email_routing() {
    local cf_email=$1
    local cf_api_key=$2
    local zone_id=$3
    local auth_method=${CF_AUTH_METHOD:-"key"}
    
    # Enable email routing
    local response
    
    if [[ "${auth_method}" == "token" ]]; then
        response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/email/routing/enable" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json")
    else
        response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/email/routing/enable" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json")
    fi

    # Check if email routing was enabled successfully
    if [[ "$(echo "${response}" | grep -o '"success":true')" ]]; then
        # Create catch-all rule
        local catchall_response
        
        if [[ "${auth_method}" == "token" ]]; then
            catchall_response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/email/routing/rules" \
                -H "Authorization: Bearer ${cf_api_key}" \
                -H "Content-Type: application/json" \
                --data '{
                    "name": "Catch-All Rule",
                    "enabled": true,
                    "matchers": [
                        {
                            "type": "all"
                        }
                    ],
                    "actions": [
                        {
                            "type": "forward",
                            "value": ["'${cf_email}'"]
                        }
                    ]
                }')
        else
            catchall_response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/email/routing/rules" \
                -H "X-Auth-Email: ${cf_email}" \
                -H "X-Auth-Key: ${cf_api_key}" \
                -H "Content-Type: application/json" \
                --data '{
                    "name": "Catch-All Rule",
                    "enabled": true,
                    "matchers": [
                        {
                            "type": "all"
                        }
                    ],
                    "actions": [
                        {
                            "type": "forward",
                            "value": ["'${cf_email}'"]
                        }
                    ]
                }')
        fi
        
        if [[ "$(echo "${catchall_response}" | grep -o '"success":true')" ]]; then
            echo "success"
        else
            local error=$(echo "${catchall_response}" | grep -o '"message":"[^"]*' | cut -d'"' -f4)
            echo "error:${error}"
        fi
    else
        local error=$(echo "${response}" | grep -o '"message":"[^"]*' | cut -d'"' -f4)
        echo "error:${error}"
    fi
}

_create_turnstile() {
    local cf_email=$1
    local cf_api_key=$2
    local zone_id=$3
    local site_name=$4
    local auth_method=${CF_AUTH_METHOD:-"key"}
    
    # Create Turnstile site key
    local response
    
    if [[ "${auth_method}" == "token" ]]; then
        response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/turnstile/widgets" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data '{
                "name": "'${site_name}'",
                "domains": ["*.'${site_name}'", "'${site_name}'"],
                "mode": "managed"
            }')
    else
        response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${zone_id}/turnstile/widgets" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data '{
                "name": "'${site_name}'",
                "domains": ["*.'${site_name}'", "'${site_name}'"],
                "mode": "managed"
            }')
    fi

    # Check if Turnstile was created successfully
    if [[ "$(echo "${response}" | grep -o '"success":true')" ]]; then
        local site_key=$(echo "${response}" | grep -o '"sitekey":"[^"]*' | cut -d'"' -f4)
        local secret_key=$(echo "${response}" | grep -o '"secret":"[^"]*' | cut -d'"' -f4)
        echo "success:${site_key}:${secret_key}"
    else
        local error=$(echo "${response}" | grep -o '"message":"[^"]*' | cut -d'"' -f4)
        echo "error:${error}"
    fi
}

_update_security_mode() {
    local cf_email=$1
    local cf_api_key=$2
    local zone_id=$3
    local mode=$4  # under_attack or development
    local value=$5  # on or off
    local auth_method=${CF_AUTH_METHOD:-"key"}
    
    local setting_name
    if [[ "${mode}" == "under_attack" ]]; then
        setting_name="security_level"
        if [[ "${value}" == "on" ]]; then
            value="under_attack"
        else
            value="medium"
        fi
    else  # development mode
        setting_name="development_mode"
        if [[ "${value}" == "on" ]]; then
            value="on"
        else
            value="off"
        fi
    fi
    
    # Update security mode
    local response
    
    if [[ "${auth_method}" == "token" ]]; then
        response=$(curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/${zone_id}/settings/${setting_name}" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data "{\"value\":\"${value}\"}")
    else
        response=$(curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/${zone_id}/settings/${setting_name}" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json" \
            --data "{\"value\":\"${value}\"}")
    fi

    # Check if the setting was updated successfully
    if [[ "$(echo "${response}" | grep -o '"success":true')" ]]; then
        echo "success"
    else
        local error=$(echo "${response}" | grep -o '"message":"[^"]*' | cut -d'"' -f4)
        echo "error:${error}"
    fi
}

_get_cloudflare_account_info() {
    local cf_email=$1
    local cf_api_key=$2
    local auth_method=${3:-"key"}
    
    # Get account information
    local response
    
    if [[ "${auth_method}" == "token" ]]; then
        response=$(curl -s -X GET "https://api.cloudflare.com/client/v4/user" \
            -H "Authorization: Bearer ${cf_api_key}" \
            -H "Content-Type: application/json")
    else
        response=$(curl -s -X GET "https://api.cloudflare.com/client/v4/user" \
            -H "X-Auth-Email: ${cf_email}" \
            -H "X-Auth-Key: ${cf_api_key}" \
            -H "Content-Type: application/json")
    fi

    echo "${response}"
}

_make_api_request() {
    local method=$1
    local endpoint=$2
    local cf_email=$3
    local cf_api_key=$4
    local auth_method=${5:-"key"}
    local data=${6:-""}
    
    local curl_cmd="curl -s -X ${method} \"https://api.cloudflare.com/client/v4/${endpoint}\""
    
    if [[ "${auth_method}" == "token" ]]; then
        curl_cmd="${curl_cmd} -H \"Authorization: Bearer ${cf_api_key}\""
    else
        curl_cmd="${curl_cmd} -H \"X-Auth-Email: ${cf_email}\" -H \"X-Auth-Key: ${cf_api_key}\""
    fi
    
    curl_cmd="${curl_cmd} -H \"Content-Type: application/json\""
    
    if [[ -n "${data}" ]]; then
        curl_cmd="${curl_cmd} --data '${data}'"
    fi
    
    response=$(eval "${curl_cmd}")
    echo "${response}"
}

# Parse JSON function if jq is not available
_parse_json_array() {
    local json_string="$1"
    
    _debug_log "Parsing JSON array - input length: ${#json_string}"
    
    # Check if response contains success field
    if [[ "${json_string}" == *'"success":false'* ]]; then
        _debug_log "API call failed - success is false"
        local error_msg=$(echo "${json_string}" | sed -n 's/.*"message":"\([^"]*\)".*/\1/p')
        _debug_log "Error message: ${error_msg}"
        return 1
    fi
    
    # Check if result array exists
    if [[ "${json_string}" != *'"result":'* ]]; then
        _debug_log "No result field found in response"
        return 1
    fi
    
    # Simple JSON parsing for DNS records
    # Extract the result array content
    local result_content=$(echo "${json_string}" | sed -n 's/.*"result":\[\([^]]*\)\].*/\1/p')
    
    if [[ -z "${result_content}" ]]; then
        _debug_log "Result array is empty or not found"
        return 1
    fi
    
    _debug_log "Result content found, parsing records..."
    
    # Split records by },{ pattern
    echo "${result_content}" | sed 's/},{/}\n{/g' | while IFS= read -r record; do
        # Only process A and AAAA records
        if [[ "${record}" == *'"type":"A"'* ]] || [[ "${record}" == *'"type":"AAAA"'* ]]; then
            local id=$(echo "${record}" | sed -n 's/.*"id":"\([^"]*\)".*/\1/p')
            local type=$(echo "${record}" | sed -n 's/.*"type":"\([^"]*\)".*/\1/p')
            local name=$(echo "${record}" | sed -n 's/.*"name":"\([^"]*\)".*/\1/p')
            local content=$(echo "${record}" | sed -n 's/.*"content":"\([^"]*\)".*/\1/p')
            local proxied=$(echo "${record}" | sed -n 's/.*"proxied":\([^,}]*\).*/\1/p')
            local ttl=$(echo "${record}" | sed -n 's/.*"ttl":\([^,}]*\).*/\1/p')
            
            _debug_log "Found record: ${type} ${name} -> ${content} (proxied: ${proxied})"
            echo "${id}|${type}|${name}|${content}|${proxied}|${ttl}"
        fi
    done
}

# Debug function for DNS management
_debug_log() {
    local message="$1"
    local debug_file="/tmp/cloudflare_dns_debug.log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ${message}" >> "${debug_file}"
    echo "[DEBUG] ${message}"
}

_debug_response() {
    local response="$1"
    local operation="$2"
    local debug_file="/tmp/cloudflare_dns_debug.log"
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] === ${operation} RESPONSE ===" >> "${debug_file}"
    echo "${response}" >> "${debug_file}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] === END RESPONSE ===" >> "${debug_file}"
    
    # Also show first 200 chars of response for immediate feedback
    echo "[DEBUG] ${operation} response preview: ${response:0:200}..."
}
